# Dynamic Programming, Greedy Algorithms
This course is part of Foundations of *Data Structures and Algorithms Specialization*

Advanced level
Recommended experience

Flexible schedule
Approx. 37 hours
Learn at your own pace

What you'll learn
Describe basic algorithm design techniques

Create divide and conquer, dynamic programming, and greedy algorithms

Understand intractable problems, P vs NP and the use of integer programming solvers to tackle some of these problems

Skills you'll gain

Algorithm Design

Python Programming

Data Structure Design

Intractability

Analysis of Algorithms

There are 4 modules in this course
This course covers basic algorithm design techniques such as divide and conquer, dynamic programming, and greedy algorithms. It concludes with a brief introduction to intractability (NP-completeness) and using linear/integer programming solvers for solving optimization problems. We will also cover some advanced topics in data structures.

**Divide and Conquer Algorithms**

We will formally cover divide and conquer algorithms as a design scheme and look at some divide and conquer algorithms we have encountered in the past. We will learn some divide and conquer algorithms for Integer Multiplication (Karatsuba’s Algorithm), Matrix Multiplication (Strassen’s Algorithm), Fast Fourier Transforms (FFTs), and Finding Closest Pair of Points.

| **📹 Videos**                                           | **Duración** |
|-------------------------------------------------------|--------------| 
| What Are Divide and Conquer Algorithms?               | 7 minutos    |
| Max Subarray Problem Using Divide and Conquer         | 23 minutos   |
| Karatsuba’s Multiplication Algorithm                  | 39 minutos   |
| Master Method Revisited                               | 28 minutos   |
| FFT Part 1: Introduction and Complex Numbers          | 48 minutos   |
| FFT Part 2: Definition and Interpretation of Discrete Fourier Transforms | 34 minutos   |
| FFT Part 3: Divide and Conquer Algorithm for FFT      | 22 minutos   |
| Application #1: Fast Polynomial Multiplication using FFT | 8 minutos    |
| Application #2: Data Analysis using FFT               | 17 minutos   |
| **Total: 9**                                          | **231 minutos**  |

| **📖 Lecturas**                                        | **Duración** |
|-------------------------------------------------------|--------------| 
| Earn Academic Credit for Your Work!                   | 10 minutos   |
| Course Support                                        | 10 minutos   |
| Reading: Important Prerequisites                      | 10 minutos   |
| Logistics: Textbook and Readings                      | 10 minutos   |
| Important Specialization Information                  | 10 minutos   |
| Overview of Module 1                                  | 10 minutos   |
| CLRS Chapter 4                                        | 10 minutos   |
| CLRS Chapter 4.1                                      | 10 minutos   |
| Jupyter Notebook on Karatsuba's Algorithm             | 10 minutos   |
| CLRS Chapters 4.3 - 4.5                               | 10 minutos   |
| Basics of Complex Numbers                             | 10 minutos   |
| Fourier Transforms                                    | 10 minutos   |
| Fast Fourier Transform                                | 10 minutos   |
| **Total: 13**                                         | **130 minutos**  |

| **📝 Quizzes**                                         | **Duración** |
|-------------------------------------------------------|--------------| 
| Max Subarray Problem                                  | 30 minutos   |
| Karatsuba's Multiplication Algorithm                  | 30 minutos   |
| Master Method                                         | 30 minutos   |
| Complex Numbers and Roots of Unity                    | 30 minutos   |
| FFT Algorithm and Applications                        | 30 minutos   |
| **Total: 5**                                          | **150 minutos**  |

### Asignación de programación
| **💻 Programming Assignment**                          | **Duración** |
|-------------------------------------------------------|--------------| 
| Problem Set 1                                         | 180 minutos  |
| **Total: 1**                                          | **180 minutos** |

### Prompts de discusión
| **💬 Discussion Prompt**                               | **Duración** |
|-------------------------------------------------------|--------------| 
| Introduce Yourself!                                   | 10 minutos   |
| **Total: 1**                                          | **10 minutos**  |

Aquí tienes la tabla organizada con los contenidos y la duración del módulo de "Dynamic Programming Algorithms":

### Videos
| **📹 Videos**                                           | **Duración** |
|-------------------------------------------------------|--------------| 
| Introduction to Dynamic Programming + Rod Cutting Problem | 30 minutos   |
| Rod Cutting Problem: Memoization                      | 23 minutos   |
| Coin Changing Problem                                  | 12 minutos   |
| Knapsack Problem                                      | 29 minutos   |
| When Optimal Substructure Fails                       | 10 minutos   |
| Dynamic Programming: Longest Common Subsequence       | 25 minutos   |
| **Total: 6**                                          | **131 minutos**  |

### Lecturas
| **📖 Lecturas**                                        | **Duración** |
|-------------------------------------------------------|--------------| 
| Overview of Module 2                                  | 10 minutos   |
| Rod Cutting Problem                                   | 10 minutos   |
| Memoization                                           | 10 minutos   |
| Coin Changing Problem                                  | 10 minutos   |
| Jupyter Notebook                                      | 10 minutos   |
| CLRS Chapter 15.4                                    | 10 minutos   |
| **Total: 6**                                          | **60 minutos**  |

### Quizzes
| **📝 Quizzes**                                         | **Duración** |
|-------------------------------------------------------|--------------| 
| Memoization                                           | 30 minutos   |
| Coin Changing Problem                                  | 30 minutos   |
| Knapsack Problem                                      | 30 minutos   |
| Longest Common Subsequence                             | 30 minutos   |
| Rod Cutting Problem and Recurrence                    | 30 minutos   |
| **Total: 5**                                          | **150 minutos**  |

### Asignación de programación
| **💻 Programming Assignment**                          | **Duración** |
|-------------------------------------------------------|--------------| 
| Problem Set 2                                         | 180 minutos  |
| **Total: 1**                                          | **180 minutos** |

**Dynamic Programming Algorithms**

In this module, you will learn about dynamic programming as a design principle for algorithms. We will provide a step-by-step approach to formulating a problem as a dynamic program and solving these problems using memoization. We will cover dynamic programming for finding longest common subsequences, Knapsack problem and some interesting dynamic programming applications.

Aquí tienes la tabla organizada con los contenidos, duración, e información adicional sobre el instructor y el curso:

### Dynamic Programming Algorithms

| **📹 Videos**                                           | **Duración** |
|-------------------------------------------------------|--------------| 
| Introduction to Dynamic Programming + Rod Cutting Problem | 30 minutos   |
| Rod Cutting Problem: Memoization                       | 23 minutos   |
| Coin Changing Problem                                   | 12 minutos   |
| Knapsack Problem                                       | 29 minutos   |
| When Optimal Substructure Fails                        | 10 minutos   |
| Dynamic Programming: Longest Common Subsequence        | 25 minutos   |
| **Total: 6**                                          | **131 minutos**  |

| **📖 Lecturas**                                        | **Duración** |
|-------------------------------------------------------|--------------| 
| Overview of Module 2                                  | 10 minutos   |
| Rod Cutting Problem                                   | 10 minutos   |
| Memoization                                           | 10 minutos   |
| Coin Changing Problem                                  | 10 minutos   |
| Jupyter Notebook                                       | 10 minutos   |
| CLRS Chapter 15.4                                    | 10 minutos   |
| **Total: 6**                                          | **60 minutos**  |

| **📝 Quizzes**                                         | **Duración** |
|-------------------------------------------------------|--------------| 
| Memoization                                           | 30 minutos   |
| Coin Changing Problem                                  | 30 minutos   |
| Knapsack Problem                                      | 30 minutos   |
| Longest Common Subsequence                            | 30 minutos   |
| Rod Cutting Problem and Recurrence                    | 30 minutos   |
| **Total: 5**                                          | **150 minutos**  |

#### Asignación de programación
| **💻 Programming Assignment**                          | **Duración** |
|-------------------------------------------------------|--------------| 
| Problem Set 2                                         | 180 minutos  |
| **Total: 1**                                          | **180 minutos** |

**Greedy Algorithms**

In this module, we will learn about greedy algorithms. We will understand the basic design principles for greedy algorithms and learn about a few algorithms for greedy scheduling and Huffman codes. We will also learn some interesting cases when being greedy provides a guaranteed approximation to the actual solution

Aquí tienes la tabla organizada con los contenidos y la duración para el módulo sobre algoritmos codiciosos:

### Greedy Algorithms

| **📹 Videos**                                           | **Duración** |
|-------------------------------------------------------|--------------| 
| Introduction to Greedy Algorithms                      | 20 minutos   |
| Greedy Interval Scheduling                              | 23 minutos   |
| Prefix Codes                                           | 30 minutos   |
| Huffman Codes                                         | 11 minutos   |
| Huffman Codes: Proof of Optimality                     | 17 minutos   |
| **Total: 5**                                          | **102 minutos**  |

| **📖 Lecturas**                                        | **Duración** |
|-------------------------------------------------------|--------------| 
| Overview of Module 3                                  | 10 minutos   |
| CLRS Chapter 16                                       | 10 minutos   |
| CLRS Chapters 16.1 and 16.2                           | 10 minutos   |
| CLRS Chapter 16.3                                     | 10 minutos   |
| **Total: 4**                                          | **40 minutos**  |

| **📝 Quizzes**                                         | **Duración** |
|-------------------------------------------------------|--------------| 
| Huffman Codes                                         | 30 minutos   |
| Greedy Algorithms                                      | 30 minutos   |
| Greedy Interval Scheduling                             | 30 minutos   |
| **Total: 3**                                          | **90 minutos**  |

| **💻 Programming Assignment**                          | **Duración** |
|-------------------------------------------------------|--------------| 
| Problem Set 3                                         | 180 minutos  |
| **Total: 1**                                          | **180 minutos** |

**Intractability and Supplement on Quantum Computing**

P vs NP, Examples such as Travelling Salesperson Problem, Vertex Cover, 3-Coloring and others; Integer Linear Programming and Translating Problems into Integer Programming.

Aquí tienes la tabla organizada con los contenidos y la duración para el módulo sobre intractabilidad y computación cuántica:

| **📹 Videos**                                           | **Duración** |
|-------------------------------------------------------|--------------| 
| Decision Problems and Languages                        | 36 minutos   |
| Polynomial Time Problems                               | 28 minutos   |
| NP Definition                                         | 29 minutos   |
| NP Completeness and Reductions                        | 37 minutos   |
| NP Complete Problems: Examples                        | 25 minutos   |
| Computation and Physics                               | 30 minutos   |
| Qubits and Operations                                 | 37 minutos   |
| Bell's Inequality                                     | 21 minutos   |
| Grover's Search Algorithm                             | 42 minutos   |
| **Total: 9**                                         | **288 minutos**  |

| **📖 Lecturas**                                        | **Duración** |
|-------------------------------------------------------|--------------| 
| Overview of Module 4                                  | 10 minutos   |
| CLRS Chapter 34                                       | 10 minutos   |
| CLRS Chapter 34.1                                     | 10 minutos   |
| CLRS Chapter 34.2 and 34.3                            | 10 minutos   |
| CLRS Chapter 34.5                                     | 10 minutos   |
| **Total: 5**                                          | **50 minutos**  |

#### Quizzes
| **📝 Quizzes**                                         | **Duración** |
|-------------------------------------------------------|--------------| 
| Decision Problems and Languages                        | 30 minutos   |
| Polynomial Time and Certificates                       | 30 minutos   |
| NP Completeness Problems                               | 30 minutos   |
| NP Completeness Reductions                             | 30 minutos   |
| **Total: 4**                                          | **120 minutos**  |

#### Asignación de programación
| **💻 Programming Assignment**                          | **Duración** |
|-------------------------------------------------------|--------------| 
| Problem Set 4                                         | 180 minutos  |
| **Total: 1**                                          | **180 minutos** |
